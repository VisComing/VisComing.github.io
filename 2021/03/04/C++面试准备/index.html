<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="1、内存溢出和内存泄漏的区别内存溢出 out of memory，就是内存不够用了。程序在申请内存时，没有足够的内存空间供其使用， 内存泄漏是一件严重的问题，当你申请了一块内存，在使用完后却没有释放它，可能是你忘记delete了，或者你没有保存空间的地址。导致操作系统不会回收，你也无法使用的局面。内存泄漏有时难以察觉，记得老师上课讲过例子，当时他们团队开发的项目运行几个星期就死机了，得重启一次，大">
<meta property="og:type" content="article">
<meta property="og:title" content="周瑞发的网站">
<meta property="og:url" content="http://yoursite.com/2021/03/04/C++%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/index.html">
<meta property="og:site_name" content="周瑞发的网站">
<meta property="og:description" content="1、内存溢出和内存泄漏的区别内存溢出 out of memory，就是内存不够用了。程序在申请内存时，没有足够的内存空间供其使用， 内存泄漏是一件严重的问题，当你申请了一块内存，在使用完后却没有释放它，可能是你忘记delete了，或者你没有保存空间的地址。导致操作系统不会回收，你也无法使用的局面。内存泄漏有时难以察觉，记得老师上课讲过例子，当时他们团队开发的项目运行几个星期就死机了，得重启一次，大">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p-icgo.oss-cn-beijing.aliyuncs.com/image/image-20210307090612946.png">
<meta property="article:published_time" content="2021-03-04T09:37:47.244Z">
<meta property="article:modified_time" content="2021-03-11T01:27:51.191Z">
<meta property="article:author" content="周瑞发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p-icgo.oss-cn-beijing.aliyuncs.com/image/image-20210307090612946.png">

<link rel="canonical" href="http://yoursite.com/2021/03/04/C++%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | 周瑞发的网站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">周瑞发的网站</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎访问</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            
  54 min. read
    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/04/C++%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="周瑞发">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周瑞发的网站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-04 17:37:47" itemprop="dateCreated datePublished" datetime="2021-03-04T17:37:47+08:00">2021-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-11 09:27:51" itemprop="dateModified" datetime="2021-03-11T09:27:51+08:00">2021-03-11</time>
              </span>

          
            <span id="/2021/03/04/C++%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="post-meta-item leancloud_visitors" data-flag-title="" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/04/C++%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/04/C++%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1、内存溢出和内存泄漏的区别"><a href="#1、内存溢出和内存泄漏的区别" class="headerlink" title="1、内存溢出和内存泄漏的区别"></a>1、内存溢出和内存泄漏的区别</h3><p>内存溢出 out of memory，就是内存不够用了。程序在申请内存时，没有足够的内存空间供其使用，</p>
<p>内存泄漏是一件严重的问题，当你申请了一块内存，在使用完后却没有释放它，可能是你忘记delete了，或者你没有保存空间的地址。导致操作系统不会回收，你也无法使用的局面。内存泄漏有时难以察觉，记得老师上课讲过例子，当时他们团队开发的项目运行几个星期就死机了，得重启一次，大概率是碰到了内存泄漏。然后内存泄漏又难以调试，不知道哪里出了问题，这也是c++的难点之一，程序员需要自己管理内存，但很容易出现问题。所以c++11推出了智能指针，用来减少内存泄漏的问题。</p>
<p>我在做项目时也遇到过一次内存泄露的问题。当时是使用sqlite，调用了sqlite3_get_table函数，该函数用来获得查询的内容。后来发现内存每分钟都在增加，我知道是内存泄漏但不知道在哪，找了很长时间。后来才知道原来在sqlite3_get_table函数内部使用malloc分配空间了，我需要调用sqlite3_free_table()才能释放掉这块内存。现在也有检查内存泄漏的工具，方便程序员调试。</p>
<p>一但内存泄漏到一定程度，系统内存就小到无法执行程序了，导致内存溢出，程序崩溃。</p>
<h2 id="2、进程与线程的区别"><a href="#2、进程与线程的区别" class="headerlink" title="2、进程与线程的区别"></a>2、进程与线程的区别</h2><p>进程是资源分配的最小单位，线程是CPU调度的最小单位</p>
<p>进程：正在执行中的程序</p>
<p>进程像一列火车，线程则是车厢，一个线程只能属于一个进程，而一个进程可以有多个线程</p>
<p>线程之间实现共享资源非常方便，但是进程间通信就比较麻烦了。</p>
<p>进程有独立的地址空间，线程没有，线程只包含一个堆栈和寄存器等</p>
<p>两个线程能否修改对方的堆栈呢，虽然我们没有这样做的意义，但是实际上是可以的，只要传递一个指向堆栈变量的指针。</p>
<h3 id="3、进程间通信IPC-Interprocess-communication"><a href="#3、进程间通信IPC-Interprocess-communication" class="headerlink" title="3、进程间通信IPC Interprocess communication"></a>3、进程间通信IPC Interprocess communication</h3><p>管道：半双工通信方法，数据只能单方向流动</p>
<p>消息队列：比管道更加高级，可以传递一个数据块，每个数据块都含有类型</p>
<p>共享内存：开辟一段能够被其他进程访问的内存。由一个进程创建，多个进程可以访问。我以前做过共享内存的实验，在linux系统中，使用了一些系统调用。</p>
<h3 id="4、自旋锁（spinlock）"><a href="#4、自旋锁（spinlock）" class="headerlink" title="4、自旋锁（spinlock）"></a>4、自旋锁（spinlock）</h3><p>一个线程想要获得锁，但该锁被其他线程占有，那么该线程会循环等待，不断的判断是否能成功获得锁，直到获得锁才退出循环。该进程在不断的判断是否能获得锁，却没有进行任何有效的任务，这种现象称为忙等待</p>
<h3 id="5、递归和迭代有啥区别"><a href="#5、递归和迭代有啥区别" class="headerlink" title="5、递归和迭代有啥区别"></a>5、递归和迭代有啥区别</h3><p>递归：函数自己调用自己，每次调用会增加一层栈帧，每次函数返回会减少一层栈帧。栈的大小是有限的，一般为8MB左右，在linux下是可以修改的。</p>
<p>尾递归：如果一个函数中所有递归形式的调用都出现在函数的末尾。普通递归会不断创建栈帧然后收缩，尾递归只占用恒定的内存（与迭代一致）。c语言是会对尾递归做优化的（编译器处理生成中间代码时，会进行优化），也就是只有一层栈帧。但java，python并不进行优化</p>
<p>迭代：将输入作为输出，再次进行处理 for(int i = 0; i &lt; 100; i++) n = f(n);</p>
<h3 id="6、什么是阻塞"><a href="#6、什么是阻塞" class="headerlink" title="6、什么是阻塞"></a>6、什么是阻塞</h3><p>打电话一直等到有人接为止</p>
<p>以前用写项目用到socket，socket默认是阻塞的，也就是程序会一直卡在这里直到收到消息。当时我们为了不使程序卡住，就采用了非阻塞的socket，当调用receive函数时，如果缓冲区里面没有东西的话立刻返回，这样程序就不会卡住了。</p>
<h3 id="7、vector对象是如何增长的"><a href="#7、vector对象是如何增长的" class="headerlink" title="7、vector对象是如何增长的"></a>7、vector对象是如何增长的</h3><p>为了支持快速随机访问，vector将元素连续存储。当我们想要插入一个新的元素是，vector如果只是简单的为我们开辟一个元素大小的空间，那么性能就会非常差，我们知道分配一次内存是及其消耗时间的。</p>
<p>vector的扩容机制不同编译器实现不一样，常用的有2倍和1.5倍。实际效率较高</p>
<p>注意、分配内存是重新分配所有内存，比如之前内存为1M， 那么要分配的内存为2M，然后将1M的数据移动过来</p>
<p>使用2倍（k=2）扩容机制扩容时，每次扩容后的新内存大小必定大于前面的总和，之前的内存不可能被使用</p>
<p>如果前面分配的内存是连续分配的，由于新内存的大小要大于前面分配内存之和，所以无法使用之前的内存了</p>
<p>而使用1.5倍（k=1.5)扩容时，在几次扩展以后，可以重用之前的内存空间了。</p>
<p>1    1.5    2.25 假设内存是连续分配的，那么2.25就可以实现内存的重用 </p>
<h3 id="8、内联函数"><a href="#8、内联函数" class="headerlink" title="8、内联函数"></a>8、内联函数</h3><p>为了解决一些频繁调用的<strong>小函数</strong>大量消耗栈内存的问题，特别的引入了 <strong>inline</strong> 修饰符，表示为内联函数。</p>
<p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p>
<p>inline只是函数对编译器的一个建议，编译器并不一定认为它是内联函数</p>
<p>定义在类中的成员函数默认是内联的</p>
<p>关键字 <strong>inline</strong> 必须与函数定义体放在一起才能使函数成为内联，仅将 <strong>inline</strong> 放在函数声明前面不起任何作用。是一种由于实现（函数实现，而非函数声明）的关键字</p>
<h3 id="9、new和malloc的区别"><a href="#9、new和malloc的区别" class="headerlink" title="9、new和malloc的区别"></a>9、new和malloc的区别</h3><p>new/delete是c++的关键字，malloc/free是库函数</p>
<p>使用new时无须指明内存块的大小，编译器会根据类型自动推断，malloc需要显示指明所需内存的大小</p>
<p>new操作符内存分配成功时，返回的是对象类型的指针，无需进行类型转换。而malloc返回的是void*，需要通过强制类型转换将void*转换为我们需要的类型</p>
<p>new分配失败时，会抛出bad_alloc异常。malloc分配失败时返回NULL</p>
<p>对于自定义类型，new会先调用operator new函数，申请足够的内存（通常底层通过malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回该类型的指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法要求其做自定义类型的对象构造和析构方法。</p>
<p>new在自由存储区上分配内存</p>
<p>每个编译器实现的new/delete可能不一样。delete关键字编译时会被分为两步：调用析构函数、调用operator delete。析构函数不会释放内存！operator delete才会。</p>
<p>new不是运算符，operator new可以重载</p>
<p>new/delete底层一般是用malloc/free实现的</p>
<h3 id="10、析构函数"><a href="#10、析构函数" class="headerlink" title="10、析构函数"></a>10、析构函数</h3><p>析构函数不负责释放自己（析构函数不会释放当前对象所在的内存，但是需要释放成员变量申请的内存）</p>
<h3 id="11、悬垂指针"><a href="#11、悬垂指针" class="headerlink" title="11、悬垂指针"></a>11、悬垂指针</h3><p>当从内存中删除一个对象或者一个函数返回时，指针的值并没有改变，依然指向先前内存的位置</p>
<h3 id="12、野指针"><a href="#12、野指针" class="headerlink" title="12、野指针"></a>12、野指针</h3><p>野指针：访问一个已销毁或者访问受限的内存区域的指针，野指针不能判断是否为NULL来避免<br>垂悬指针：指针正常初始化，曾指向一个对象，该对象被销毁了，但是指针未制空，那么就成了悬空指针。</p>
<p>产生原因：定义时为初始化，指针操作引起越界</p>
<h3 id="13、段错误"><a href="#13、段错误" class="headerlink" title="13、段错误"></a>13、段错误</h3><p>当程序试图访问不允许访问的内存位置，或试图以不允许的方式访问内存位置（例如尝试写入只读位置，或覆盖部分操作系统）时会发生段错误。</p>
<p>访问受系统保护的内存地址</p>
<p>写入只读的内存地址</p>
<p>数组越界</p>
<p>堆栈溢出</p>
<h3 id="14、逻辑运算符优先级"><a href="#14、逻辑运算符优先级" class="headerlink" title="14、逻辑运算符优先级"></a>14、逻辑运算符优先级</h3><p>! &gt; || &gt; &amp;&amp;</p>
<p>false || ture &amp;&amp; true结果为true</p>
<h3 id="15、C-三大特性"><a href="#15、C-三大特性" class="headerlink" title="15、C++三大特性"></a>15、C++三大特性</h3><p>1、封装。隐藏对象的属性和实现细节，只对外部提供接口和方法。</p>
<p>2、继承：一个对象直接使用另一个对象的属性和方法</p>
<p>​    优点：减少重复代码。继承是多态的前提。</p>
<p>3、多态：一个接口，多种方法。使用同一个接口，但是效果不同</p>
<p>​    动态多态：程序运行时才能确定链接哪一个函数，通过虚函数实现。基类存在一些接口，要求子类重写这些接口。通过基类指针调用虚函数，实际上会调用子类重写的虚函数（基类指针指向子类）</p>
<p>比如 Base * b;   Child a()； b = &a;</p>
<p>虚函数是在基类中使用关键字virtual声明的函数。在派生类中重新定义基类的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<p>要实现多态必须  1、继承  2、子类重写父类方法  3、父类引用子类对象</p>
<h3 id="16、重载与重写"><a href="#16、重载与重写" class="headerlink" title="16、重载与重写"></a>16、重载与重写</h3><p>重载(overload)：写一个与已有函数同名但参数表不同的函数</p>
<p>重写(override)：虚函数在派生类中被改写</p>
<h3 id="17、析构函数"><a href="#17、析构函数" class="headerlink" title="17、析构函数"></a>17、析构函数</h3><p>名字与类名相同，但是要在前面添加~，没有参数和返回值。</p>
<p>一个类有且仅有一个析构函数。如果定义类是没有定义析构函数，编译器会自动生成默认析构函数</p>
<p>析构函数在对象消亡时被自动调用。所以可以定义析构函数在对象消亡前完成善后工作。比如用new分配了内存，那么就可以在析构函数中统一delete。</p>
<h3 id="18、C-内存分布"><a href="#18、C-内存分布" class="headerlink" title="18、C++内存分布"></a>18、C++内存分布</h3><p>栈区</p>
<p>堆区</p>
<p>全局/静态区</p>
<p>文字常量区</p>
<p>程序代码区</p>
<p>1、栈内存  ：  由编译器自动分配释放，存储函数的参数值，局部变量值等。程序员无法控制</p>
<p>const局部变量也存储在栈区，栈区向地址减小的方向增长</p>
<p>2、堆内存：程序员向操作系统申请一片内存，应该是由操作系统决定分配策略（首次适应，最差适应）。</p>
<p>3、全局/静态区：全局变量和静态变量是存储在一起的，在程序编译时分配</p>
<p>4、文字常量区：存储常量字符串</p>
<p>5、程序代码区：存储函数体的二进制代码</p>
<h3 id="19、map和unordered-map优点和缺点"><a href="#19、map和unordered-map优点和缺点" class="headerlink" title="19、map和unordered_map优点和缺点"></a>19、map和unordered_map优点和缺点</h3><p>map：底层是基于红黑树实现的。有序性，是map最大的优点</p>
<p>map的查加、删除等一系列操作时间复杂度稳定 都为logn</p>
<p>缺点：查找、删除速度较慢、map占用空间较大</p>
<p>unordered_map：底层是哈希表</p>
<p>查找效率很高，可达O(1)</p>
<p>哈希表的建立比较费时，数据无序</p>
<p>对于查找问题，unordered_map会更加高效一些</p>
<h3 id="20、迭代器"><a href="#20、迭代器" class="headerlink" title="20、迭代器"></a>20、迭代器</h3><p>要访问顺序容器和关联容器中的元素，需要通过迭代器iterator进行。</p>
<p>正向迭代器 vector&lt;int&gt; ::iterator iter;</p>
<p>正向常量迭代器vector&lt;int&gt; ::const_iterator iter;</p>
<p>反向迭代器 vector&lt;int&gt; ::const_reverse_iterator iter;</p>
<p>迭代器不是指针，是类模板，表现的像指针。通过重载了指针的一些操作符 -&gt;  *  ++   –等封装成了指针，是一个可以遍历stl容器内全部元素或部分元素的对象。</p>
<p>迭代器返回的是对象引用而不是对象的值</p>
<h3 id="21、构造函数"><a href="#21、构造函数" class="headerlink" title="21、构造函数"></a>21、构造函数</h3><p>类的构造函数是一种特殊的成员函数，它会在每次创建类的新对象时被执行</p>
<p>名称与类名完全相同，不会返回任何类型</p>
<p>构造函数不能不能被声明为const的</p>
<p>如果定义变量时没有指定初值，则变量被默认初始化，它的值由定义的位置决定。定义在任何函数体之外的变量被初始化为0.一种例外情况是，定义在函数体内部的内置类型（int, long char, short等基本类型）将不被初始化。一个未被初始化的内置类型变量的值是未定义的。</p>
<p>Student(string &amp; s) : bookNo(s) {  }，该列表不限定初始化的具体执行顺序</p>
<p><strong>成员初始化的顺序与它们在类定义中的出现顺序一致</strong>。</p>
<p>构造函数初始值列表，如果某个数据成员被忽略时，那么它将隐式初始化（默认初始化）</p>
<p>如果没有定义构造函数，类会通过默认构造函数进行初始化。又叫合成的默认构造函数</p>
<h3 id="22、指针和引用的区别"><a href="#22、指针和引用的区别" class="headerlink" title="22、指针和引用的区别"></a>22、指针和引用的区别</h3><p>指针是一个变量，只不过这个变量存的是一个地址</p>
<p>引用是别名（绰号），对引用的任何操作都是对被引用对象的操作，既不是拷贝，也不是指针，而是源对象自己。引用没有空间</p>
<p>引用定义时必须初始化，引用不能为空</p>
<p>sizeof(引用)计算的是原对象的大小，size(指针)计算的是指针本身的大小</p>
<h3 id="23、指针的大小"><a href="#23、指针的大小" class="headerlink" title="23、指针的大小"></a>23、指针的大小</h3><ol>
<li><p>cpu位数（32位数4字节，64位数8字节）</p>
</li>
<li><p>操作系统位数（32位数4字节，64位数8字节）</p>
</li>
<li><p>编译器的位数（32位数4字节，64位数8字节）</p>
<p> 当上述三种位数不同时，取最小的位数</p>
</li>
</ol>
<h3 id="24、数组指针"><a href="#24、数组指针" class="headerlink" title="24、数组指针"></a>24、数组指针</h3><p>指向数组的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">5</span>] = a;</span><br></pre></td></tr></table></figure>

<p>p是一个指针变量，它指向包含5个int元素的一维数组，此时p的增量以它所指向的一维数组长度为单位。</p>
<p>a[1]表示第二行数组的首地址</p>
<p>*(p+1)表示a[1][0]的地址</p>
<p>*(p+2) + 3表示a[2][3]的地址</p>
<p>*（*(p+2) + 3）表示a[2][3]的值</p>
<h3 id="25、gets"><a href="#25、gets" class="headerlink" title="25、gets"></a>25、gets</h3><p>gets函数是读取字符串，以回车键结束</p>
<p>fgets是读取一行字符，以换行符结束</p>
<p>getc读入一个字符</p>
<p>fgetc读入一个字符，读取一个字节后光标位置后移一位</p>
<p>带f的是通过函数实现的，不带f的是通过宏定义实现的</p>
<h3 id="26、-o是八进制"><a href="#26、-o是八进制" class="headerlink" title="26、%o是八进制"></a>26、%o是八进制</h3><h3 id="27、转义字符"><a href="#27、转义字符" class="headerlink" title="27、转义字符"></a>27、转义字符</h3><p>转义字符以<code>\</code>或者<code>\x</code>开头，以<code>\</code>开头表示后跟八进制形式的编码值，以<code>\x</code>开头表示后跟十六进制形式的编码值。对于转义字符来说，只能使用八进制或者十六进制。</p>
<p>\0到\31是控制字符，负责控制不输出</p>
<p>\32到\127是打印字符，\开头以八进制匹配，\x以十六进制匹配</p>
<h3 id="28、set底层实现方式"><a href="#28、set底层实现方式" class="headerlink" title="28、set底层实现方式"></a>28、set底层实现方式</h3><p>红黑树，不像map那样是key-value对，set的key和value是相同的</p>
<h3 id="29、vector怎么实现的"><a href="#29、vector怎么实现的" class="headerlink" title="29、vector怎么实现的"></a>29、vector怎么实现的</h3><p>vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存。</p>
<h3 id="30、虚函数实现"><a href="#30、虚函数实现" class="headerlink" title="30、虚函数实现"></a>30、虚函数实现</h3><p>C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有多种形态。</p>
<h3 id="31、delete和delete-的区别"><a href="#31、delete和delete-的区别" class="headerlink" title="31、delete和delete[]的区别"></a>31、delete和delete[]的区别</h3><p>使用new申请的内存，释放时用delete，使用new[]申请的内存，释放用delete[]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">delete</span> [] a;</span><br></pre></td></tr></table></figure>

<p>很多人认为方法一会造成内存泄漏，然而事实是不会。针对简单的数据结构，方法一和方法二均可正常工作。因为基本的数据类型对象没有析构函数，并且new在分配内存时会记录分配的空间大小，而delete是能正确释放内存，无须调用析构函数释放其余指针，两种方式均可。</p>
<p><strong>自定义数据类型</strong>，这里一般指类。假设通过new申请了一个<strong>对象数组</strong>，返回一个指针。那么当释放此对象数组的内存时，需要做两件事：一是释放最初申请的那部分空间，二是调用析构函数完成清理工作。对于第一件事，由于new记录了申请时的大小，用delete和delete[]都可以将其正确释放。但是对于第二件事，当使用delete时，只会调用对象数组中的第一个对象的析构函数，而使用delete[]的话，则会逐个调用析构函数。</p>
<h3 id="32、vector和list的区别"><a href="#32、vector和list的区别" class="headerlink" title="32、vector和list的区别"></a>32、vector和list的区别</h3><p>list容器的工能和数据结构中的双向链表极为相似</p>
<p>list允许快速的插入和删除，但是随机存取的效率很低，O(n)</p>
<p>vector和数组类似，有一段连续的存储空间，因此可以高效随机访问。但是由于其内存空间是连续的，所以在进行插入和删除操作时，复杂度为O(n)。另外，当数组内存空间不够时，需要再申请一块空间，然后将原来空间的数组复制过来。</p>
<h3 id="33、class与struct的区别"><a href="#33、class与struct的区别" class="headerlink" title="33、class与struct的区别"></a>33、class与struct的区别</h3><p>成员的默认访问权限：class默认是private，struct默认是public</p>
<p>默认继承权限：如果不指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理</p>
<p>C++中，class和struct功能基本一致。</p>
<h3 id="34、拷贝构造函数"><a href="#34、拷贝构造函数" class="headerlink" title="34、拷贝构造函数"></a>34、拷贝构造函数</h3><p>一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</p>
<p>通常用于：通过使用另一个同类型的对象来初始化新对象的对象/复制对象把它作为参数传递给函数/复制对象，并从函数返回这个对象。</p>
<h3 id="35、继承的目的"><a href="#35、继承的目的" class="headerlink" title="35、继承的目的"></a>35、继承的目的</h3><p>实现代码重用，最大程度利用原有的代码，具有普遍性的方法继承下来，减少代码量</p>
<p>派生的目的：当新的问题出现时，原有程序不能完全解决，需要对原有程序程序进行改造</p>
<p>class   派生类名  ：  继承方式  基类名 {</p>
<p>​    成员声明；</p>
<p>}</p>
<p>calss D : public B</p>
<p>公有继承，是一个  is-a关系，每一个类型为D的对象都是一个类型为B的对象</p>
<p>每一个学生都是一个人</p>
<p>公有继承都可以用是一个关系去描述</p>
<p>但是是一个关系都能用公有继承去建模</p>
<p>是一个关系不等于公有继承</p>
<h3 id="36、复合关系"><a href="#36、复合关系" class="headerlink" title="36、复合关系"></a>36、复合关系</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">calss Person &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    ...</span><br><span class="line">    PhoneNumber mobileNuber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>has a关系</p>
<p>person和phonenumber是有一个的关系</p>
<p>is implemented in terms of 根据某物实现</p>
<p>要实现一个集合，已经实现了一个链表</p>
<p>calss Set : public List{}  ?这样合适吗？不合适，链表不应该被集合继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Set &#123;</span><br><span class="line">private:</span><br><span class="line">	list items;&#x2F;&#x2F;根据链表来实现集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>三种关系</p>
<p>公有继承是是一个关系</p>
<p>是一个关系不一定能用公有继承来建模</p>
<p>复合关系：有一个关系，根据某物实现</p>
<h3 id="37、私有继承"><a href="#37、私有继承" class="headerlink" title="37、私有继承"></a>37、私有继承</h3><p>私有继承绝对不是是一个关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class A : private B&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>编译器不会将派生类自动转换成基类</p>
<p>通过私有继承，基类中的<strong>所有属性</strong>在派生类中都变成了私有属性</p>
<p>用下面的复合关系来替代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">private: </span><br><span class="line">	B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在绝大多数情况下，上下的代码一样</p>
<p>私有继承仅仅是一种实现技术，在软件设计层面上是没有意义的</p>
<p>使用根据某物实现的关系替代私有继承</p>
<p>不要使用私有继承</p>
<p>没有人能弄懂保护继承，忘记它</p>
<p>私有继承相当于根据某物实现的关系，不建议使用，使用复合关系替代</p>
<p>保护继承：忘了它吧</p>
<p>派生类可以继承成员函数的接口和实现</p>
<p>虚函数、非虚函数、纯虚函数</p>
<p>有纯虚函数的类不能实例化对象</p>
<p>声明纯虚函数的目的：使派生类仅仅继承函数的接口</p>
<p>虚函数的目的：使派生类继承函数的接口和缺省实现</p>
<p>非虚函数的目的：使派生类继承函数的接口和强制性实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译没有错误，只是有一个警告</p>
<p>D x</p>
<p>B *pB = &amp;x</p>
<p>pB-&gt;mf2()会调用B的mf2函数</p>
<p>D *pD = &amp;x</p>
<p>pD-&gt;mf2()会调用D的mf2函数</p>
<p>同一个对象，不同的指针指向它，行为却不同，一种类似精神分类的症状</p>
<p>所以不许重新定义非虚函数</p>
<h3 id="38、多态"><a href="#38、多态" class="headerlink" title="38、多态"></a>38、多态</h3><p>调用同一个函数/方法，不同的对象会产生不同的行为</p>
<p>多态四种实现方式</p>
<p>表面的实现方式</p>
<p>​    强制多态：通过将数据进行类型转换实现</p>
<p>​    函数重载（只有返回值类型不同，不能构成重载，函数const属性不同属于重载）</p>
<h3 id="39、extern"><a href="#39、extern" class="headerlink" title="39、extern"></a>39、extern</h3><p>全局变量可以为本文件中的其他函数所共用，它的有效范围是从定义变量的位置开始到本源文件结束。</p>
<p>要想在定义点之前引用该全局变量，则应该在引用之前使用关键字extern对该变量作“外部变量声明”，表示该变量是一个已经定义的外部变量。</p>
<p>声明可以进行多次，但定义只有一次。</p>
<p>比如在一个.c文件中定义了一个全局变量 int a，那么要在.h文件中使用extern int a声明。如果其他文件想要使用该全局变量，则只需将它的头文件添加进来即可。</p>
<h3 id="40、浅拷贝、深拷贝"><a href="#40、浅拷贝、深拷贝" class="headerlink" title="40、浅拷贝、深拷贝"></a>40、浅拷贝、深拷贝</h3><p>对一个已知对象进行拷贝，会自动调用一种构造函数—拷贝构造函数，如果用户没有定义，那么会调用默认拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">    Student() &#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student a;</span><br><span class="line">    <span class="function">student <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用一次构造函数，调用两次析构函数，会出错。因为默认构造函数执行的是浅拷贝，即对name拷贝后会出现两个指针指向同一块内存区域。</p>
<p>所以在对含有指针成员的对象进行拷贝时，必须要自己定义拷贝构造函数，使拷贝后的对象指针成员有自己的内存空间，即进行深拷贝。</p>
<p>Student(const Student&amp; s) {</p>
<p>​    name = new char[20];</p>
<p>​    memcpy(name, s.name, strlen(s,name));</p>
<p>}</p>
<p>浅拷贝只是对指针本身的拷贝，拷贝后的两个指针指向同一内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经过深拷贝后的指针是指向两个不同地址的指针。</p>
<p>当函数的参数为对象时，实参传递给形参的实际是实参的一个拷贝，会调用拷贝构造函数。</p>
<p>当参数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处。</p>
<p>浅拷贝带来问题的本质在于析构函数释放多次堆内存，使用std::shared_ptr可以解决。</p>
<h3 id="41、int-a-5-0，1，-2，-3，-4"><a href="#41、int-a-5-0，1，-2，-3，-4" class="headerlink" title="41、int a[5] = {0，1， 2， 3， 4}"></a>41、int a[5] = {0，1， 2， 3， 4}</h3><p>*(a + 1)  = 1</p>
<p>&amp;a + 1相当于加了一个数组的偏移，即指向4后面的那一个位置</p>
<p><code>(((int*)(&amp;a + 1)) - 1) = 4</code></p>
<h3 id="42、const-char-a-“hello”"><a href="#42、const-char-a-“hello”" class="headerlink" title="42、const char * a = “hello”"></a>42、const char * a = “hello”</h3><p>存储在常量区，不能更改</p>
<h3 id="43、空类的大小"><a href="#43、空类的大小" class="headerlink" title="43、空类的大小"></a>43、空类的大小</h3><p>class A{};</p>
<p>sizeof(A)为1</p>
<p>空类的大小为1个字节：因为空类可以实例化，实例化必然再内存中占有一个位置，因此，编译器为其优化为1个字节。</p>
<p>class B: public A {</p>
<p>​    int b;</p>
<p>}</p>
<p>B类的大小为4个字节，因为B类中定义了int变量。在空基类被继承后，子类会优化掉基类的1字节大小，节省了空间大小，提高运行效率</p>
<p>与类大小有关的因素：普通成员变量、虚函数、继承</p>
<p>与类大小无关的因素：静态成员变量、静态成员函数及普通成员函数。</p>
<p>class A{virtual void f(){}};</p>
<p>A的大小为指针的大小（4或8个字节），有虚函数表的地址。</p>
<h3 id="44、字节对齐"><a href="#44、字节对齐" class="headerlink" title="44、字节对齐"></a>44、字节对齐</h3><p>内存对齐主要遵循下面三个原则</p>
<p>公式一、前面的地址必须是后面地址的整数倍，不是就补齐</p>
<p>公式二、整个struct的地址必须是最大字节的整数倍</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    short c;</span><br><span class="line">&#125;</span><br><span class="line">1000 1111 1100</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">	int a;</span><br><span class="line">	char b;</span><br><span class="line">	char c;</span><br><span class="line">&#125;;</span><br><span class="line">1111 1100</span><br></pre></td></tr></table></figure>

<p>每个<strong>特定平台</strong>上的编译器都有自己的默认“<strong>对齐系数</strong>”。可以通过预编译命令#pragma pack(n)</p>
<h3 id="45、char-a-“XYZ”-char-b-“XYZ”"><a href="#45、char-a-“XYZ”-char-b-“XYZ”" class="headerlink" title="45、char* a = “XYZ”; char* b = “XYZ”"></a>45、char* a = “XYZ”; char* b = “XYZ”</h3><p>“XYZ”存储在常量区,</p>
<p>a, b指向同一个地址。</p>
<h3 id="46、函数指针"><a href="#46、函数指针" class="headerlink" title="46、函数指针"></a>46、函数指针</h3><p>函数指针指向函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p>
<p><code>bool lengthCompare(const string &amp;, const string &amp;);</code></p>
<p>该函数的类型为<code>bool (const string &amp;, const string &amp;)</code></p>
<p>要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可:</p>
<p><code>bool (*pf)(const string &amp;, const string &amp;);</code></p>
<p>*pf左右两边的括号必不可少。如果不写这对括号，变成了函数pf，返回值为bool指针</p>
<p>使用函数指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool (*p)(const string&amp;, const string&amp;);</span><br><span class="line">pf &#x3D; lengthCompare;</span><br><span class="line">pf &#x3D; &amp;lengthCompare;</span><br><span class="line">&#x2F;&#x2F;二者是等价的，pf指向名为lengthCompare的函数</span><br></pre></td></tr></table></figure>

<p>此外，我们还可以直接使用指向函数的指针调用该函数，无须提前解引用指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool b1 &#x3D; pf(&quot;ni&quot;, &quot;hao&quot;);</span><br><span class="line">bool b2 &#x3D; (*pf)(&quot;ni&quot;, &quot;hao&quot;);</span><br><span class="line">bool b3 &#x3D; lengthCompare(&quot;ni&quot;, &quot;hao&quot;);</span><br><span class="line">&#x2F;&#x2F;以上三种写法是等价的</span><br></pre></td></tr></table></figure>

<h3 id="47、a-i-j"><a href="#47、a-i-j" class="headerlink" title="47、a[i][j]"></a>47、a[i][j]</h3><p>(*(a + i))[j]           *(a + i)[j]是错误的</p>
<p>*(*(a+ i) + j)</p>
<p>*(&amp;a[0][0] + 4 * i + j)</p>
<h3 id="48、二维数组和二级指针"><a href="#48、二维数组和二级指针" class="headerlink" title="48、二维数组和二级指针"></a>48、二维数组和二级指针</h3><p>两者不一样</p>
<p>int *<em>p，p是一个指针，指向int\</em></p>
<p>int a[4][5]</p>
<p>a是二维数组名，首先是一个指针，指向一个含有5个元素的int型数组</p>
<p>a和a[0]的值一样，a[0]是一个一维数组，也是一个指针常量，该指针的值是数组第一个元素的地址。</p>
<p>a[0] = &amp;a[0][0]</p>
<p>归并排序第二步合并是归并名字的由来</p>
<h3 id="49、快速排序"><a href="#49、快速排序" class="headerlink" title="49、快速排序"></a>49、快速排序</h3><p>快排的最优时间复杂度是O(nlogn)，最差复杂度为O(n^2)</p>
<p>空间复杂度最优为O(logn),最差为O(n);</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(q[++i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span>(q[--j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">std</span>::swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    quick_sort(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="50、int-p-new-int-10-int-p-new-int-10"><a href="#50、int-p-new-int-10-int-p-new-int-10" class="headerlink" title="50、int *p = new int[10]; int *p = new int[10]()"></a>50、int *p = new int[10]; int *p = new int[10]()</h3><p>对于内置类型而言，new仅仅是分配内存，除非后面加上（），相当于调用它的构造函数</p>
<p>对于自定义类型而言，只要一调用呢哇，那么编译器不仅仅给它分配内存，还会调用它的构造函数进行初始化，即使后面没有加（）</p>
<h3 id="51、char-str"><a href="#51、char-str" class="headerlink" title="51、char str[]"></a>51、char str[]</h3><p>strlen计算字符串的长度，不包含’’\0’</p>
<p>sizeof计算<strong>内存</strong>的大小   char str[100] = “qqq”  sizeof(str) = 100; </p>
<p>char str[] = “Hello”;</p>
<p>*str = ‘H’       sizeof(str) = 6          strlen(str) = 5</p>
<p>printf(“%s”, str)        Hello</p>
<p>printf(“%s”, str + 1) ello</p>
<p>C语言中操作字符串是通过它在内存中的存储单元的首地址进行的，这是字符串的终极本质。</p>
<p>对于数组 str = &amp; str[0]</p>
<p>const char *str = “Hello”</p>
<p>*str = ‘H’        sizeof(str) = 8(指针大小)        strlen(str) = 5</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">char</span> acWelcome[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="keyword">sizeof</span>(acWelcome));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> acWelcome[] = <span class="string">&quot;Welcome to Huawei Test&quot;</span>;</span><br><span class="line">    example(acWelcome);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, <span class="keyword">sizeof</span>(acWelcome));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p-icgo.oss-cn-beijing.aliyuncs.com/image/image-20210307090612946.png" alt="image-20210307090612946"></p>
<p>数组名作为参数传递时，数组名退化为指针，传递过去的其实是数组的首地址</p>
<h3 id="52、多态"><a href="#52、多态" class="headerlink" title="52、多态"></a>52、多态</h3><p>多态性分为编译时多态性和运行时多态性，</p>
<p>编译时多态性通过静态编联完成，例如函数重载，运算符重载；</p>
<p>运行时多态性则是动态编联完成，主要通过虚函数来实现；</p>
<h3 id="53、linux查看系统进程"><a href="#53、linux查看系统进程" class="headerlink" title="53、linux查看系统进程"></a>53、linux查看系统进程</h3><p>ps：显示所有运行中的进程</p>
<p>top：进程了动态图，包括cpu、内存、运行时间等</p>
<h3 id="54、linux让进程后台运行"><a href="#54、linux让进程后台运行" class="headerlink" title="54、linux让进程后台运行"></a>54、linux让进程后台运行</h3><p>当用户注销或网络断开时，终端会收到hangup：HUP信号关闭所有子进程。因此，解决办法就有两条途径：要么让进程忽略HUP信号，要么让进程在新的会话里从而成为不属于此终端的子进程</p>
<p>1、nohup</p>
<p>可以让提交的命令忽略hangup信号</p>
<p>nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上”&amp;”来将命令同时放入后台运行，也可用”&gt;filename 2&gt;&amp;1”来更改缺省的重定向文件名。</p>
<p>nohup不会让任务变为后台任务，需要加上&amp;</p>
<p>2、setsid</p>
<p>进程ID叫做PID</p>
<p>可以设置该进程的父进程为init进程</p>
<p>3、&amp;</p>
<p>只要在命令的尾部加上符号&amp;，启动的进程就会成为后台进程。如果要让正在运行的前台任务变为后台任务，可以按ctrl+z暂停该程序，然后执行bg命令（让最近一个暂停的后台任务继续执行）</p>
<p>4、disown</p>
<p>可以将指定任务从后台任务列表删除，后台任务不在列表中，那么session就不会向它发出SIGHUP信号。</p>
<p>5、终端复用器</p>
<p>Screen 和 tmux</p>
<h3 id="55、快排空间复杂度"><a href="#55、快排空间复杂度" class="headerlink" title="55、快排空间复杂度"></a>55、快排空间复杂度</h3><p>每次递归需要的空间是固定的，总体空间复杂度即递归层数，因此平均/最好复杂度为O(nlog)，最坏空间复杂度为O(n);</p>
<h3 id="56、C-逗号表达式"><a href="#56、C-逗号表达式" class="headerlink" title="56、C++逗号表达式"></a>56、C++逗号表达式</h3><p>使用逗号运算符是为了把几个表达式放在一起。</p>
<p>整个逗号表达式的值为系列中最后一个表达式的值。</p>
<p>从本质上讲，逗号的作用是将一系列运算按顺序执行。</p>
<p>表达式1，表达式2</p>
<p>求解过程是：先求表达式1，在求表达式2。整个逗号表达式的值是表达式2的值。</p>
<p>最右边的那盒表达式的值将作为整个逗号表达式的值，其他表达式的值会被丢弃。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/28/%E9%BE%99%E9%AA%A8%E4%BA%BA%E5%81%B6/" rel="prev" title="龙骨人偶">
      <i class="fa fa-chevron-left"></i> 龙骨人偶
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/07/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">1、内存溢出和内存泄漏的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number"></span> <span class="nav-text">2、进程与线程的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1IPC-Interprocess-communication"><span class="nav-number">1.</span> <span class="nav-text">3、进程间通信IPC Interprocess communication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88spinlock%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">4、自旋锁（spinlock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">5、递归和迭代有啥区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E"><span class="nav-number">4.</span> <span class="nav-text">6、什么是阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81vector%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%A2%9E%E9%95%BF%E7%9A%84"><span class="nav-number">5.</span> <span class="nav-text">7、vector对象是如何增长的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">8、内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">9、new和malloc的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">10、析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81%E6%82%AC%E5%9E%82%E6%8C%87%E9%92%88"><span class="nav-number">9.</span> <span class="nav-text">11、悬垂指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88"><span class="nav-number">10.</span> <span class="nav-text">12、野指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81%E6%AE%B5%E9%94%99%E8%AF%AF"><span class="nav-number">11.</span> <span class="nav-text">13、段错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">12.</span> <span class="nav-text">14、逻辑运算符优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15%E3%80%81C-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">13.</span> <span class="nav-text">15、C++三大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E3%80%81%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="nav-number">14.</span> <span class="nav-text">16、重载与重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">15.</span> <span class="nav-text">17、析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18%E3%80%81C-%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="nav-number">16.</span> <span class="nav-text">18、C++内存分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19%E3%80%81map%E5%92%8Cunordered-map%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">17.</span> <span class="nav-text">19、map和unordered_map优点和缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">18.</span> <span class="nav-text">20、迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">19.</span> <span class="nav-text">21、构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">20.</span> <span class="nav-text">22、指针和引用的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23%E3%80%81%E6%8C%87%E9%92%88%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">21.</span> <span class="nav-text">23、指针的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24%E3%80%81%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="nav-number">22.</span> <span class="nav-text">24、数组指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25%E3%80%81gets"><span class="nav-number">23.</span> <span class="nav-text">25、gets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26%E3%80%81-o%E6%98%AF%E5%85%AB%E8%BF%9B%E5%88%B6"><span class="nav-number">24.</span> <span class="nav-text">26、%o是八进制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27%E3%80%81%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="nav-number">25.</span> <span class="nav-text">27、转义字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28%E3%80%81set%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">26.</span> <span class="nav-text">28、set底层实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29%E3%80%81vector%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">27.</span> <span class="nav-text">29、vector怎么实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">28.</span> <span class="nav-text">30、虚函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31%E3%80%81delete%E5%92%8Cdelete-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">29.</span> <span class="nav-text">31、delete和delete[]的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32%E3%80%81vector%E5%92%8Clist%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">30.</span> <span class="nav-text">32、vector和list的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33%E3%80%81class%E4%B8%8Estruct%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">31.</span> <span class="nav-text">33、class与struct的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">32.</span> <span class="nav-text">34、拷贝构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">33.</span> <span class="nav-text">35、继承的目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36%E3%80%81%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB"><span class="nav-number">34.</span> <span class="nav-text">36、复合关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37%E3%80%81%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="nav-number">35.</span> <span class="nav-text">37、私有继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38%E3%80%81%E5%A4%9A%E6%80%81"><span class="nav-number">36.</span> <span class="nav-text">38、多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39%E3%80%81extern"><span class="nav-number">37.</span> <span class="nav-text">39、extern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">38.</span> <span class="nav-text">40、浅拷贝、深拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41%E3%80%81int-a-5-0%EF%BC%8C1%EF%BC%8C-2%EF%BC%8C-3%EF%BC%8C-4"><span class="nav-number">39.</span> <span class="nav-text">41、int a[5] &#x3D; {0，1， 2， 3， 4}</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42%E3%80%81const-char-a-%E2%80%9Chello%E2%80%9D"><span class="nav-number">40.</span> <span class="nav-text">42、const char * a &#x3D; “hello”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43%E3%80%81%E7%A9%BA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">41.</span> <span class="nav-text">43、空类的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44%E3%80%81%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="nav-number">42.</span> <span class="nav-text">44、字节对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45%E3%80%81char-a-%E2%80%9CXYZ%E2%80%9D-char-b-%E2%80%9CXYZ%E2%80%9D"><span class="nav-number">43.</span> <span class="nav-text">45、char* a &#x3D; “XYZ”; char* b &#x3D; “XYZ”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">44.</span> <span class="nav-text">46、函数指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47%E3%80%81a-i-j"><span class="nav-number">45.</span> <span class="nav-text">47、a[i][j]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88"><span class="nav-number">46.</span> <span class="nav-text">48、二维数组和二级指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">47.</span> <span class="nav-text">49、快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50%E3%80%81int-p-new-int-10-int-p-new-int-10"><span class="nav-number">48.</span> <span class="nav-text">50、int *p &#x3D; new int[10]; int *p &#x3D; new int[10]()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51%E3%80%81char-str"><span class="nav-number">49.</span> <span class="nav-text">51、char str[]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52%E3%80%81%E5%A4%9A%E6%80%81"><span class="nav-number">50.</span> <span class="nav-text">52、多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53%E3%80%81linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B"><span class="nav-number">51.</span> <span class="nav-text">53、linux查看系统进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54%E3%80%81linux%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="nav-number">52.</span> <span class="nav-text">54、linux让进程后台运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55%E3%80%81%E5%BF%AB%E6%8E%92%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">53.</span> <span class="nav-text">55、快排空间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56%E3%80%81C-%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">54.</span> <span class="nav-text">56、C++逗号表达式</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">周瑞发</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">233</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">周瑞发</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'Ytq8BzsrCa111NhWVN9J8rHG-gzGzoHsz',
      appKey     : 'XPYBCP4RPAeMshHIS2bbs9tb',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
